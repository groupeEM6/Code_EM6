# Code_arduino
Code déplacement robot et traçage de symboles 
#include <Arduino.h>
#include <math.h>
#include <Servo.h> 
struct point
{
    int x;
    int y;
};

// Coordonnées des cases

point Case1 = {15, 75};
point Case2 = {45, 75};
point Case3 = {75, 75};
point Case4 = {15, 45};
point Case5 = {45, 45};
point Case6 = {75, 45};
point Case7 = {15, 15};
point Case8 = {45, 15};
point Case9 = {75, 15};

// Infos proto : diamètre des roues , longueur axe entre roues

float d_roue = 6.5;

float axe = 16.5;

// Coordonnées initiales du proto

point P_0 = {-30,45};


float n_rotation(point P) 
{
    /* calcule nbre de tours à parcourir par roue pour alignement avec trajectoire
    (n tours pour roue de gauche, -n tours pour roue de droite) */

    float theta = atan2((P.y - P_0.y),(P.x - P_0.x));
    
    float arc_cercle = (axe/2)*theta;

    float n_tours = arc_cercle/(3.14*d_roue);

    return n_tours;
}

float n_parcours(point P)
{
    /*Calcule le nbre de tours à parcourir par la roue pour arriver à la case
    une fois la trajectoire alignée*/

    float distance = pow(pow(P.x-P_0.x, 2) + pow(P.y-P_0.y, 2), 0.5);
    
    float n_tours = distance/(3.14*d_roue);

    return n_tours;
};


// ratio ticks/tour
int tick_par_tour = 40;

// vitesse moteur désirée
int vitesse_moteur = 100;

// pins moteur gauche
int MOTEUR_G_IN = 11;
int MOTEUR_G_ENA = 5;
int ENCODEUR_G_A = 14;
int ENCODEUR_G_B = 18;
float compteur_G = 0;
int G_A_etat_precedent = LOW;

// pins moteur droite
int MOTEUR_D_IN = 8;
int MOTEUR_D_ENA = 6;
int ENCODEUR_D_A = 15;
int ENCODEUR_D_B = 19;
float compteur_D = 0;
int D_A_etat_precedent = LOW;

// pin servo moteur 
const int PIN_SERVO = 3;
Servo stylo; 

// Temps pour faire un cercle complet (à calibrer)
int temps_cercle = 4500;  // ms = 3 secondes environ
// dessin pour la croix
float temps_par_cm = 100.0;   // ms par cm (à calibrer)
float temps_par_deg = 10.0;   // ms par degré (à calibrer)

// PWM/DIR pour fonctions avancer/reculer 
const int DIR1 = 11;
const int PWM1 = 10;
const int DIR2 = 8;
const int PWM2 = 9;
const int vitesse = 120; // pour fonctions avancer/reculer
void setup() 
{
    Serial.begin(9600);

    pinMode(MOTEUR_G_IN, OUTPUT);
    pinMode(MOTEUR_G_ENA, OUTPUT);
    pinMode(MOTEUR_D_IN, OUTPUT);
    pinMode(MOTEUR_D_ENA, OUTPUT);
   
    pinMode(ENCODEUR_G_A, INPUT_PULLUP);
    pinMode(ENCODEUR_G_B, INPUT_PULLUP);
    pinMode(ENCODEUR_D_A, INPUT_PULLUP);
    pinMode(ENCODEUR_D_B, INPUT_PULLUP);
    
    // attachInterrupt(digitalPinToInterrupt(ENCODEUR_G_A), lireEncodeurGauche, CHANGE);
    // attachInterrupt(digitalPinToInterrupt(ENCODEUR_D_A), lireEncodeurDroite, CHANGE);
    
    arreterMoteurs();
  stylo.attach(PIN_SERVO);
  stylo.write(60); // stylo levé
  delay(500);
}



void loop() 
{
    // Exemple de séquence de déplacement : Aller à la Case5, puis s'arrêter.
    
    // On ne veut exécuter cette séquence qu'une seule fois.
    static bool a_deja_bouge = false; 

    if (!a_deja_bouge) {
        
        point CaseCible = Case5; // Définir la case cible
        
        
        // 1. Calculer et effectuer la rotation
        float tours_rotation = n_rotation(CaseCible);

        // Rotation : (G: tours_rotation, D: -tours_rotation) -> on passe tours_rotation à la fonction
        tournerRobot(tours_rotation);
        

        // 2. Calculer et effectuer l'avancement
        float tours_parcours = n_parcours(CaseCible);

        // Avancer : (G: tours_parcours, D: tours_parcours)
        deplacerRobotAvant(tours_parcours);


        // 3. Mettre à jour la position du robot (P_0)
        P_0 = CaseCible; 

        // 4. Baisser le stylo 
        stylo.write(78);  // stylo bas
        delay(300);

        //5. Dessiner un cercle sur place 
        dessinerCercle();
        
        a_deja_bouge = true; // Le déplacement est terminé.
    }
        // Le robot reste immobile après le traçage
        while(true); 
    }
    
 // ------ DESSINER UN CERCLE ------
void dessinerCercle() {
 // Une roue arrêtée (droite)
 analogWrite(PWM2, 0);

// L'autre moteur (gauche) tourne
digitalWrite(DIR1, HIGH);
analogWrite(PWM1, vitesse);

delay(temps_cercle); // durée pour un cercle complet
// Arrêt
analogWrite(PWM1, 0);
analogWrite(PWM2, 0);
stylo.write(60); // stylo levé
    
}
//---DESSINER UNE CROIX
void dessinerCroix() {
float Ldiag = 20.0 * 1.41421356237; // ≈ 28.284 cm
float moitiéLdiag = Ldiag / 2.0;

  // --- Tracer la première diagonale (coin A → coin C) ---
  // Place le robot AU COIN A, orienté vers coin C
  styloEcrit(true);
  avancer(Ldiag);
  styloEcrit(false);
  
  // Revenir jusqu'à la moitié de la 1ere diagonale 
  reculer(moitiéLdiag);

  // Tracer la 2e digonale depuis le centre
  tournerRobot( (3.14159/2) * (axe/2) / d_roue );  // rotation de 90°
  styloEcrit(true);
  avancer(moitiéLdiag);
  styloEcrit(false);
  reculer(moitiéLdiag);
  styloEcrit(false);
}
// Baisser et remonter le stylo
void styloEcrit(bool bas){
  if(bas) stylo.write(120); 
  else stylo.write(60);
  delay(300);
}

void avancer(float cm){
  int t = (int)round(cm * temps_par_cm);
  digitalWrite(DIR1, HIGH); analogWrite(PWM1, vitesse);
  digitalWrite(DIR2, HIGH); analogWrite(PWM2, vitesse);
  delay(t);
  arret();
}

void reculer(float cm){
  int t = (int)round(cm * temps_par_cm);
  digitalWrite(DIR1, LOW); analogWrite(PWM1, vitesse);
  digitalWrite(DIR2, LOW); analogWrite(PWM2, vitesse);
  delay(t);
  arret();
}

void arret(){
  analogWrite(PWM1,0); analogWrite(PWM2,0);
  delay(100);
}

void lireEncodeurGauche()
{
    // L'encodeur A est lu en continu (polling) pour détecter les fronts montants ou descendants.
    int G_A_etat_courant = digitalRead(ENCODEUR_G_A);

    // Ne réagit que si l'état a changé (détection d'une impulsion)
    if (G_A_etat_courant != G_A_etat_precedent) 
    {
        // Détection de la direction
        if (digitalRead(ENCODEUR_G_B) == G_A_etat_courant) {
             // Exemple : si A est LOW et B est LOW (ou A est HIGH et B est HIGH)
            compteur_G--; // Rotation arrière
        } else {
            // Exemple : si A est LOW et B est HIGH (ou A est HIGH et B est LOW)
            compteur_G++; // Rotation avant
        }
    }
    G_A_etat_precedent = G_A_etat_courant;
}

void lireEncodeurDroite()
{
    // L'encodeur A est lu en continu (polling) pour détecter les fronts montants ou descendants.
    int D_A_etat_courant = digitalRead(ENCODEUR_D_A);

    // Ne réagit que si l'état a changé (détection d'une impulsion)
    if (D_A_etat_courant != D_A_etat_precedent) 
    {
        // Détection de la direction
        if (digitalRead(ENCODEUR_D_B) == D_A_etat_courant) {
            compteur_D--; // Rotation arrière
        } else {
            compteur_D++; // Rotation avant
        }
    }

    // Mettre à jour l'état précédent pour la prochaine détection
    D_A_etat_precedent = D_A_etat_courant;
}

void demarrerMoteurGauche(int vitesse) 
{
    digitalWrite(MOTEUR_G_IN, HIGH);
    analogWrite(MOTEUR_G_ENA, vitesse);
}

void demarrerMoteurDroit(int vitesse) 
{
    digitalWrite(MOTEUR_D_IN, HIGH);
    analogWrite(MOTEUR_D_ENA, vitesse);
}

void reculerMoteurGauche(int vitesse) 
{
    // Inverse la direction par rapport à demarrerMoteurGauche
    digitalWrite(MOTEUR_G_IN, LOW);
    analogWrite(MOTEUR_G_ENA, vitesse);
}

void reculerMoteurDroit(int vitesse) 
{
    // Inverse la direction par rapport à demarrerMoteurDroit
    digitalWrite(MOTEUR_D_IN, LOW);
    analogWrite(MOTEUR_D_ENA, vitesse);
}

void arreterMoteurs() 
{
    analogWrite(MOTEUR_G_ENA, 0);
    analogWrite(MOTEUR_D_ENA, 0);
    digitalWrite(MOTEUR_G_IN, LOW);
    digitalWrite(MOTEUR_D_IN, LOW);
}

void deplacerRobotAvant(float toursCibles) 
{
    
    float target_pulses = toursCibles * tick_par_tour;
    
    compteur_G = 0;
    compteur_D = 0; 

    demarrerMoteurGauche(vitesse_moteur);
    demarrerMoteurDroit(vitesse_moteur);
    

    while (compteur_G < target_pulses || compteur_D < target_pulses) {
        
        lireEncodeurGauche(); 
        lireEncodeurDroite();

        // Correction de l'écart
        float ecart = compteur_G - compteur_D; 
        
        
        if (ecart > 10) { 
            analogWrite(MOTEUR_G_ENA, vitesse_moteur - 20);
        } 

        else if (ecart < -10) {
            analogWrite(MOTEUR_D_ENA, vitesse_moteur - 20); 
        } 

        else {
            analogWrite(MOTEUR_G_ENA, vitesse_moteur);
            analogWrite(MOTEUR_D_ENA, vitesse_moteur);
        }
 
        if (compteur_G >= target_pulses && compteur_D >= target_pulses) {
            break; 
        }
        
        delay(10); 
    }
    
    arreterMoteurs();
}

void tournerRobot(float toursCibles) {
    /*
    Fait tourner le robot sur place.
    toursCibles positif : roue gauche avance (+), roue droite recule (-) -> Rotation anti-horaire (à gauche)
    toursCibles négatif : roue gauche recule (-), roue droite avance (+) -> Rotation horaire (à droite)
    */
    
    // Convertir les tours cibles en impulsions d'encodeur
    float target_pulses = fabs(toursCibles) * tick_par_tour; // Utilisez la valeur absolue

    compteur_G = 0;
    compteur_D = 0; 
    
    // Déterminer la direction de chaque moteur
    if (toursCibles >= 0) {
        // Rotation anti-horaire (vers la gauche)
        demarrerMoteurGauche(vitesse_moteur); // G: Avance
        reculerMoteurDroit(vitesse_moteur);   // D: Recule
    } else {
        // Rotation horaire (vers la droite)
        reculerMoteurGauche(vitesse_moteur);  // G: Recule
        demarrerMoteurDroit(vitesse_moteur);   // D: Avance
    }

    // Le robot tourne tant que l'une des roues n'a pas atteint sa cible
    // ATTENTION : Pour une rotation, on compare les valeurs absolues des compteurs
    while (fabs(compteur_G) < target_pulses || fabs(compteur_D) < target_pulses) {
        
        lireEncodeurGauche(); 
        lireEncodeurDroite();

        // Correction de l'écart (optionnel, mais recommandé pour un pivot précis)
        // L'écart doit être mesuré sur les valeurs absolues des compteurs.
        float ecart = fabs(compteur_G) - fabs(compteur_D); 
        
        // Ajustement de la vitesse pour synchroniser les deux roues
        if (ecart > 10) { 
            // La roue G est en avance (en magnitude)
            analogWrite(MOTEUR_G_ENA, vitesse_moteur - 20);
        } 
        else if (ecart < -10) {
            // La roue D est en avance (en magnitude)
            analogWrite(MOTEUR_D_ENA, vitesse_moteur - 20); 
        } 
        else {
            analogWrite(MOTEUR_G_ENA, vitesse_moteur);
            analogWrite(MOTEUR_D_ENA, vitesse_moteur);
        }
 
        // Si les deux compteurs ont atteint ou dépassé la cible (en valeur absolue)
        if (fabs(compteur_G) >= target_pulses && fabs(compteur_D) >= target_pulses) {
            break; 
        }
        
        delay(10); // Petite pause pour ne pas saturer le microcontrôleur
    }
    
    arreterMoteurs();
}
